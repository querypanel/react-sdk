import { useEffect, useState, useCallback } from "react";
import { DashboardViewer } from "./DashboardViewer";
import { DashboardEditor } from "./DashboardEditor";
import type { Dashboard } from "../types";
import type { ColorPreset, Theme } from "../types";

export interface QuerypanelEmbeddedProps {
  /** Dashboard ID to display */
  dashboardId: string;
  /** JWT token for authentication (generated by customer backend) */
  token: string;
  /** API base URL */
  apiBaseUrl?: string;

  /** Enable customer customization (copy-on-write) */
  allowCustomization?: boolean;

  /** Color preset for theming */
  colorPreset?: ColorPreset;
  /** Custom theme override */
  theme?: Partial<Theme>;
  /** Use dark mode */
  darkMode?: boolean;

  /** Callbacks */
  onError?: (error: Error) => void;
  onLoad?: (dashboard: Dashboard) => void;
  onCustomize?: (forkedDashboard: Dashboard) => void;
}

/**
 * Embedded dashboard component with optional customer customization
 */
export function QuerypanelEmbedded({
  dashboardId,
  token,
  apiBaseUrl = "https://api.querypanel.com",
  allowCustomization = false,
  colorPreset = "default",
  theme,
  darkMode = false,
  onError,
  onLoad,
  onCustomize,
}: QuerypanelEmbeddedProps) {
  // Suppress unused warning for theme/colorPreset until styling is implemented
  void colorPreset;
  void theme;
  const [dashboard, setDashboard] = useState<Dashboard | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isFork, setIsFork] = useState(false);

  // Fetch dashboard (or fork if exists)
  const fetchDashboard = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      // Backend will extract tenantId from JWT token
      const response = await fetch(
        `${apiBaseUrl}/dashboards/${dashboardId}/for-tenant`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        }
      );

      if (!response.ok) {
        throw new Error(`Failed to fetch dashboard: ${response.statusText}`);
      }

      const data: Dashboard = await response.json();
      if (data.dashboard_type === "internal") {
        setDashboard(null);
        setIsFork(false);
        throw new Error("This dashboard is not available for embedding.");
      }
      setDashboard(data);
      setIsFork(data.is_customer_fork);
      onLoad?.(data);
    } catch (err) {
      const error = err instanceof Error ? err : new Error("Unknown error");
      setError(error.message);
      onError?.(error);
    } finally {
      setLoading(false);
    }
  }, [apiBaseUrl, dashboardId, token, onLoad, onError]);

  useEffect(() => {
    fetchDashboard();
  }, [fetchDashboard]);

  // Fork the dashboard
  const handleFork = async () => {
    try {
      // Backend will extract tenantId from JWT token
      const response = await fetch(`${apiBaseUrl}/dashboards/${dashboardId}/fork`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({}),
      });

      if (!response.ok) {
        throw new Error(`Failed to fork dashboard: ${response.statusText}`);
      }

      const fork: Dashboard = await response.json();
      setDashboard(fork);
      setIsFork(true);
      setIsEditing(true);
      onCustomize?.(fork);
    } catch (err) {
      const error = err instanceof Error ? err : new Error("Unknown error");
      setError(error.message);
      onError?.(error);
    }
  };

  // Save fork changes
  const handleSave = async (content: string) => {
    if (!dashboard) return;

    try {
      // Backend will extract tenantId from JWT token
      const response = await fetch(`${apiBaseUrl}/dashboards/forks/${dashboard.id}`, {
        method: "PUT",
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          content_json: content,
        }),
      });

      if (!response.ok) {
        throw new Error(`Failed to save fork: ${response.statusText}`);
      }

      const updated: Dashboard = await response.json();
      setDashboard(updated);
      setIsEditing(false);
    } catch (err) {
      const error = err instanceof Error ? err : new Error("Unknown error");
      setError(error.message);
      onError?.(error);
    }
  };

  // Rollback to original
  const handleRollback = async () => {
    if (!dashboard) return;

    if (!confirm("Reset to original dashboard? Your customizations will be lost.")) {
      return;
    }

    try {
      // Backend will extract tenantId from JWT token
      const response = await fetch(
        `${apiBaseUrl}/dashboards/forks/${dashboard.id}/rollback`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({}),
        }
      );

      if (!response.ok) {
        throw new Error(`Failed to rollback fork: ${response.statusText}`);
      }

      const original: Dashboard = await response.json();
      setDashboard(original);
      setIsFork(false);
      setIsEditing(false);
    } catch (err) {
      const error = err instanceof Error ? err : new Error("Unknown error");
      setError(error.message);
      onError?.(error);
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center py-16">
        <div
          className="w-8 h-8 border-4 border-t-transparent rounded-full animate-spin"
          style={{ borderColor: theme?.colors?.primary || "#8B5CF6" }}
        />
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-6 bg-red-50 dark:bg-red-900/20 rounded-lg">
        <h3 className="text-lg font-semibold text-red-900 dark:text-red-100 mb-2">
          Error Loading Dashboard
        </h3>
        <p className="text-red-700 dark:text-red-300">{error}</p>
      </div>
    );
  }

  if (!dashboard) {
    return (
      <div className="p-6 bg-gray-50 dark:bg-gray-900 rounded-lg">
        <p className="text-gray-700 dark:text-gray-300">Dashboard not found</p>
      </div>
    );
  }

  return (
    <div className="querypanel-embedded">
      {/* Toolbar */}
      {allowCustomization && (
        <div className="flex items-center justify-between mb-4 p-4 bg-gray-50 dark:bg-gray-900 rounded-lg">
          <div className="flex items-center gap-2">
            <h2 className="text-xl font-semibold">{dashboard.name}</h2>
            {isFork && (
              <span className="px-2 py-1 text-xs font-medium bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-200 rounded">
                Customized
              </span>
            )}
          </div>
          <div className="flex items-center gap-2">
            {!isEditing && !isFork && (
              <button
                type="button"
                onClick={handleFork}
                className="px-4 py-2 text-sm font-medium text-white bg-purple-600 hover:bg-purple-700 rounded-lg transition-colors"
              >
                Customize Dashboard
              </button>
            )}
            {!isEditing && isFork && (
              <>
                <button
                  type="button"
                  onClick={() => setIsEditing(true)}
                  className="px-4 py-2 text-sm font-medium text-white bg-purple-600 hover:bg-purple-700 rounded-lg transition-colors"
                >
                  Edit
                </button>
                <button
                  type="button"
                  onClick={handleRollback}
                  className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition-colors"
                >
                  Reset to Original
                </button>
              </>
            )}
            {isEditing && (
              <button
                type="button"
                onClick={() => setIsEditing(false)}
                className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition-colors"
              >
                Cancel
              </button>
            )}
          </div>
        </div>
      )}

      {/* Content */}
      {isEditing ? (
        <DashboardEditor
          initialContent={dashboard.content_json || ""}
          onSave={handleSave}
          darkMode={darkMode}
        />
      ) : (
        <DashboardViewer
          content={dashboard.content_json || ""}
          token={token}
          apiBaseUrl={apiBaseUrl}
          darkMode={darkMode}
          className="min-h-[400px]"
        />
      )}
    </div>
  );
}
